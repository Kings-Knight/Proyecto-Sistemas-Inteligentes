# -*- coding: utf-8 -*-
"""Position processing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1epW10lzTDw6M7M-6xBp3Gj3ZY4ti9vM-
"""

import pandas as pd
import numpy as np
import csv # Using standard csv module for efficient row-by-row writing
from tqdm.auto import tqdm # For progress bar

# --- Constants and Mappings ---

PIECE_TO_VALUE_FEN_PARSER = {
    'P': 1, 'N': 2, 'B': 3, 'R': 4, 'Q': 5, 'K': 6,
    'p': -1, 'n': -2, 'b': -3, 'r': -4, 'q': -5, 'k': -6,
    '.': 0  # Represent empty squares if needed during intermediate board setup
}

# Reverse mapping for visualization
VALUE_TO_PIECE_CHAR = {v: k for k, v in PIECE_TO_VALUE_FEN_PARSER.items()}
# Ensure 0 maps to '.' for empty squares if not already covered
if 0 not in VALUE_TO_PIECE_CHAR:
    VALUE_TO_PIECE_CHAR[0] = '.'


PIECE_RAW_MATERIAL_VALUE = {
    # Using absolute piece type as key for value, sign indicates color elsewhere
    1: 1, 2: 3, 3: 3.5, 4: 5, 5: 9, 6: 0,  # King value 0 for material count
}

# --- Piece Square Tables (PSTs) ---
# Values are typically in centipawns.
# For black pieces, the table is read from black's perspective (mirrored index).

knight_pos = np.array([
   -200, -100,   -50,   -50,   -50,   -50, -100, -200,
   -100,     0,     0,     0,     0,     0,     0, -100,
    -50,     0,    60,    60,    60,    60,     0,   -50,
    -50,     0,    30,    60,    60,    30,     0,   -50,
    -50,     0,    30,    60,    60,    30,     0,   -50,
    -50,     0,    30,    30,    30,    30,     0,   -50,
   -100,     0,     0,     0,     0,     0,     0, -100,
   -200,   -50,   -25,   -25,   -25,   -25,   -50, -200
], dtype=np.int32)

pawn_pos = np.array([
      0,   0,   0,   0,   0,   0,   0,   0,
     50,  50,  50,  50,  50,  50,  50,  50,
     10,  10,  20,  30,  30,  20,  10,  10,
      5,   5,  10,  25,  25,  10,   5,   5,
      0,   0,   0,  20,  20,   0,   0,   0,
      5,  -5, -10,   0,   0, -10,  -5,   5,
      5,  10,  10, -20, -20,  10,  10,   5,
      0,   0,   0,   0,   0,   0,   0,   0
], dtype=np.int32)

bishop_pos = np.array([
   -20, -10, -10, -10, -10, -10, -10, -20,
   -10,   0,   0,   0,   0,   0,   0, -10,
   -10,   0,   5,  10,  10,   5,   0, -10,
   -10,   5,   5,  10,  10,   5,   5, -10,
   -10,   0,  10,  10,  10,  10,   0, -10,
   -10,  10,  10,  10,  10,  10,  10, -10,
   -10,   5,   0,   0,   0,   0,   5, -10,
   -20, -10, -10, -10, -10, -10, -10, -20
], dtype=np.int32)

rook_pos = np.array([
      0,   0,   0,   5,   5,   0,   0,   0,
      5,  10,  10,  10,  10,  10,  10,   5,
     -5,   0,   0,   0,   0,   0,   0,  -5,
     -5,   0,   0,   0,   0,   0,   0,  -5,
     -5,   0,   0,   0,   0,   0,   0,  -5,
     -5,   0,   0,   0,   0,   0,   0,  -5,
     -5,   0,   0,   0,   0,   0,   0,  -5,
      0,   0,   0,   5,   5,   0,   0,   0
], dtype=np.int32)

queen_pos = np.array([
   -20, -10, -10,  -5,  -5, -10, -10, -20,
   -10,   0,   0,   0,   0,   0,   0, -10,
   -10,   0,   5,   5,   5,   5,   0, -10,
    -5,   0,   5,   5,   5,   5,   0,  -5,
     0,   0,   5,   5,   5,   5,   0,  -5,
   -10,   5,   5,   5,   5,   5,   0, -10,
   -10,   0,   5,   0,   0,   0,   0, -10,
   -20, -10, -10,  -5,  -5, -10, -10, -20
], dtype=np.int32)

king_mg_pos = np.array([
   -30, -40, -40, -50, -50, -40, -40, -30,
   -30, -40, -40, -50, -50, -40, -40, -30,
   -30, -40, -40, -50, -50, -40, -40, -30,
   -30, -40, -40, -50, -50, -40, -40, -30,
   -20, -30, -30, -40, -40, -30, -30, -20,
   -10, -20, -20, -20, -20, -20, -20, -10,
    20,  20,   0,   0,   0,   0,  20,  20,
    20,  30,  10,   0,   0,  10,  30,  20
], dtype=np.int32)


PSTS = {
    1: pawn_pos, 2: knight_pos, 3: bishop_pos, 4: rook_pos, 5: queen_pos, 6: king_mg_pos,
    # For black pieces, the same PSTs are used but indices are mirrored
}

# --- Helper Functions ---

def square_to_index(sq_name):
    """Converts algebraic square notation (e.g., 'a1', 'h8') to 0-63 index."""
    if sq_name == '-' or not isinstance(sq_name, str) or len(sq_name) != 2:
        return -1 # For en passant when not available
    col = ord(sq_name[0]) - ord('a')
    row = int(sq_name[1]) - 1 # '1' maps to row 0, '8' to row 7
    return row * 8 + col

def get_mirrored_square_index(idx):
    """Mirrors a square index for Black's perspective when using PSTs (a1 <-> a8)."""
    if idx < 0 or idx > 63: return idx
    row = idx // 8
    # col = idx % 8 # Column doesn't change with simple mirroring
    return (7 - row) * 8 + (idx % 8)

# --- FEN Parsing ---
def parse_fen(fen_string):
    """Parses a FEN string into its components."""
    parts = fen_string.split()
    if len(parts) != 6:
        raise ValueError(f"Invalid FEN string format: {fen_string}")

    board_repr = [0] * 64
    fen_board = parts[0]
    # FEN board parsing: ranks are listed from 8 down to 1.
    # Our board_array: index 0 is a1, 7 is h1, 56 is a8, 63 is h8.
    # So, we fill from rank 7 (8th rank) downwards.
    current_rank_idx = 7 # Start with the 8th rank (board_array rows 7 down to 0)
    current_file_idx = 0 # Start with 'a' file (board_array cols 0 up to 7)

    for char in fen_board:
        if char == '/':
            current_rank_idx -= 1
            current_file_idx = 0
            if current_rank_idx < 0:
                 raise ValueError(f"Too many ranks in FEN board part: {fen_board}")
        elif char.isdigit():
            skip_squares = int(char)
            current_file_idx += skip_squares
            if current_file_idx > 8:
                 raise ValueError(f"Too many squares in a rank in FEN board part: {fen_board}")
        elif char in PIECE_TO_VALUE_FEN_PARSER:
            if current_file_idx >= 8:
                 raise ValueError(f"Too many pieces/squares in a rank in FEN board part: {fen_board}")
            board_idx = current_rank_idx * 8 + current_file_idx
            board_repr[board_idx] = PIECE_TO_VALUE_FEN_PARSER[char]
            current_file_idx += 1
        else:
             raise ValueError(f"Invalid character in FEN board part: {char} in {fen_board}")

    # Basic validation for board representation length
    if len(board_repr) != 64:
         raise ValueError(f"Parsed board representation has incorrect size: {len(board_repr)}")


    side_to_move_str = parts[1]
    if side_to_move_str == 'w':
        side_to_move = 1
    elif side_to_move_str == 'b':
        side_to_move = -1
    else:
        raise ValueError(f"Invalid side to move in FEN: {side_to_move_str}")

    castling_fen = parts[2]
    # More robust check for castling availability string
    valid_castling_chars = set('KQkq-')
    if not set(castling_fen).issubset(valid_castling_chars):
         raise ValueError(f"Invalid castling availability string in FEN: {castling_fen}")

    white_can_castle = 1 if 'K' in castling_fen or 'Q' in castling_fen else 0
    black_can_castle = 1 if 'k' in castling_fen or 'q' in castling_fen else 0

    en_passant_sq_str = parts[3]
    # Validate en passant square string
    if en_passant_sq_str != '-' and (len(en_passant_sq_str) != 2 or not en_passant_sq_str[0].isalpha() or not en_passant_sq_str[1].isdigit()):
         raise ValueError(f"Invalid en passant square string in FEN: {en_passant_sq_str}")
    en_passant_sq_idx = square_to_index(en_passant_sq_str)
    # Further validation: if not '-', check if it's a valid pawn capture square (rank 3 for black, rank 6 for white)
    if en_passant_sq_idx != -1:
        ep_row = en_passant_sq_idx // 8
        if (side_to_move == 1 and ep_row != 5) or (side_to_move == -1 and ep_row != 2):
             # This check is more advanced and might require board state knowledge
             # For now, we'll just validate the format and index range
             if not (0 <= en_passant_sq_idx < 64):
                  raise ValueError(f"En passant square index out of range: {en_passant_sq_idx}")


    try:
        halfmove_clock = int(parts[4])
        if halfmove_clock < 0:
             raise ValueError("Halfmove clock cannot be negative.")
    except ValueError:
        raise ValueError(f"Invalid halfmove clock in FEN: {parts[4]}")

    try:
        fullmove_counter = int(parts[5])
        if fullmove_counter < 1:
             raise ValueError("Fullmove counter must be at least 1.")
    except ValueError:
        raise ValueError(f"Invalid fullmove counter in FEN: {parts[5]}")


    return {
        "board_array": board_repr,
        "side_to_move": side_to_move,
        "white_castle_any": white_can_castle,
        "black_castle_any": black_can_castle,
        "en_passant_sq_idx": en_passant_sq_idx,
        "halfmove_clock": halfmove_clock,
        "fullmove_counter": fullmove_counter
    }

# --- Attack Generation Logic ---

def get_square_coordinates(idx):
    return idx // 8, idx % 8 # row, col (0-7)

def is_valid_square(r, c):
    return 0 <= r < 8 and 0 <= c < 8

def get_piece_attacks(board_array, piece_idx):
    """Gets all squares attacked by the piece at piece_idx."""
    attacked_squares = set()
    piece_val = board_array[piece_idx]
    if piece_val == 0: return attacked_squares

    piece_type_abs = abs(piece_val)
    piece_color = 1 if piece_val > 0 else -1
    r_orig, c_orig = get_square_coordinates(piece_idx)

    if piece_type_abs == 1: # Pawn
        direction = 1 if piece_color == 1 else -1 # White moves towards higher ranks, Black towards lower
        # Pawn attacks are on squares [r_orig + direction, c_orig +/- 1]
        for dc_attack in [-1, 1]:
            r_target, c_target = r_orig + direction, c_orig + dc_attack
            if is_valid_square(r_target, c_target):
                attacked_squares.add(r_target * 8 + c_target)

    elif piece_type_abs == 2: # Knight
        knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]
        for dr, dc in knight_moves:
            r_target, c_target = r_orig + dr, c_orig + dc
            if is_valid_square(r_target, c_target):
                attacked_squares.add(r_target * 8 + c_target)

    elif piece_type_abs == 6: # King
        king_moves = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
        for dr, dc in king_moves:
            r_target, c_target = r_orig + dr, c_orig + dc
            if is_valid_square(r_target, c_target):
                attacked_squares.add(r_target * 8 + c_target)
    else: # Bishop, Rook, Queen (Sliding pieces)
        move_directions = []
        if piece_type_abs == 3: # Bishop
            move_directions = [(1,1),(1,-1),(-1,1),(-1,-1)]
        elif piece_type_abs == 4: # Rook
            move_directions = [(1,0),(-1,0),(0,1),(0,-1)]
        elif piece_type_abs == 5: # Queen
            move_directions = [(1,1),(1,-1),(-1,1),(-1,-1),(1,0),(-1,0),(0,1),(0,-1)]

        for dr, dc in move_directions:
            for i in range(1, 8):
                r_target, c_target = r_orig + i * dr, c_orig + i * dc
                if not is_valid_square(r_target, c_target): break

                target_sq_idx = r_target * 8 + c_target
                attacked_squares.add(target_sq_idx)
                # Check if the square contains a piece. Any piece blocks sliding pieces.
                if board_array[target_sq_idx] != 0:
                    break # Stop sliding in this direction

    return attacked_squares

def calculate_attack_map(board_array):
    """Calculates the attack map for the given board state."""
    attack_map = [0] * 64
    for i in range(64):
        if board_array[i] != 0:
            piece_val = board_array[i]
            piece_color = 1 if piece_val > 0 else -1
            attacked_by_this_piece = get_piece_attacks(board_array, i)
            for attacked_sq_idx in attacked_by_this_piece:
                 # Add the color of the attacking piece to the attacked square's value
                 # Positive for white attacks, negative for black attacks
                attack_map[attacked_sq_idx] += piece_color
    return attack_map

# --- Material and Positional Value Calculation ---
def calculate_material_and_positional_value(board_array):
    """Calculates raw material and positional values for both sides."""
    raw_white_material = 0
    raw_black_material = 0
    pos_white_value = 0
    pos_black_value = 0

    for i in range(64): # Iterate through each square
        piece_val = board_array[i]
        if piece_val == 0: continue

        piece_abs_val = abs(piece_val)

        # Raw material calculation
        material_val = PIECE_RAW_MATERIAL_VALUE.get(piece_abs_val, 0)
        if piece_val > 0: # White piece
            raw_white_material += material_val
            pst = PSTS.get(piece_abs_val)
            if pst is not None:
                pos_white_value += pst[i] # White uses direct index
        else: # Black piece
            raw_black_material += material_val
            pst = PSTS.get(piece_abs_val)
            if pst is not None:
                mirrored_idx = get_mirrored_square_index(i)
                pos_black_value += pst[mirrored_idx] # Black uses mirrored index

    return {
        "raw_white_material": raw_white_material,
        "raw_black_material": raw_black_material,
        "pos_white_value": pos_white_value,
        "pos_black_value": pos_black_value
    }

# --- Main Processing Function ---
def process_chess_position(fen_string, evaluation):
    """
    Processes a single chess position (FEN and evaluation) into a list of features.
    Returns the list of features.
    """
    fen_data = parse_fen(fen_string)
    board_array = fen_data["board_array"]
    attack_map = calculate_attack_map(board_array)
    value_data = calculate_material_and_positional_value(board_array)

    features = list(board_array) # Start with the 64 board squares
    features.extend([
        fen_data["side_to_move"], fen_data["white_castle_any"], fen_data["black_castle_any"],
        fen_data["en_passant_sq_idx"], fen_data["halfmove_clock"], fen_data["fullmove_counter"]
    ])
    features.extend(attack_map)
    features.append(evaluation) # Add the original evaluation
    features.extend([
        value_data["raw_white_material"], value_data["raw_black_material"],
        value_data["pos_white_value"], value_data["pos_black_value"]
    ])
    return features # Return only the list of features

# --- Visualization Function ---
def visualize_position(fen_string, board_array, attack_map):
    """Prints a text-based visualization of the board and attack map."""
    print(f"FEN: {fen_string}")

    print("\nBoard State:")
    # Print ranks from 8 down to 1
    for r in range(7, -1, -1): # rank index 7 (8th rank) down to 0 (1st rank)
        line = f"{r+1} | "
        for c in range(8): # file index 0 (a-file) to 7 (h-file)
            piece_val = board_array[r * 8 + c]
            line += f"{VALUE_TO_PIECE_CHAR.get(piece_val, '?')} " # '?' for unknown
        print(line)
    print("  +------------------")
    print("    a b c d e f g h")

    print("\nAttack Map (White: positive, Black: negative):")
    for r in range(7, -1, -1):
        line = f"{r+1} | "
        for c in range(8):
            attack_val = attack_map[r * 8 + c]
            line += f"{attack_val:>3} " # {:>3} ensures alignment for numbers
        print(line)
    print("  +--------------------------")
    print("    a  b  c  d  e  f  g  h")
    print("-" * 30)


# --- Row-by-Row Processing and CSV Writing ---
def process_and_save_chess_data(input_csv_path, output_csv_path, visualize_first_n=0):
    """
    Reads chess data from input_csv_path, processes each position,
    and writes the processed features to output_csv_path row by row.
    Includes a progress bar.
    """
    # Define column names
    board_cols = [f'sq_{i}' for i in range(64)]
    fen_detail_cols = ['side_to_move', 'white_castle_any', 'black_castle_any',
                       'en_passant_sq_idx', 'halfmove_clock', 'fullmove_counter']
    attack_map_cols = [f'attack_map_{i}' for i in range(64)]
    eval_col = ['evaluation']
    material_pos_cols = ['raw_white_material', 'raw_black_material',
                         'pos_white_value', 'pos_black_value']
    all_columns = board_cols + fen_detail_cols + attack_map_cols + eval_col + material_pos_cols
    expected_feature_count = len(all_columns)

    try:
        # Read the input CSV to get the total number of rows for the progress bar
        # This still loads the FENs and evaluations into memory, but not the processed features.
        input_df = pd.read_csv(input_csv_path)
        if "FEN" not in input_df.columns or "Evaluation" not in input_df.columns:
            raise ValueError("Input CSV must contain 'FEN' and 'Evaluation' columns.")

        positions_to_process = list(input_df[['FEN', 'Evaluation']].itertuples(index=False, name=None))
        total_positions = len(positions_to_process)
        print(f"Loaded {total_positions} positions from '{input_csv_path}' for processing.")

    except FileNotFoundError:
        print(f"ERROR: Input CSV file not found at '{input_csv_path}'. Please create it or check the path.")
        return # Exit if input file not found
    except ValueError as ve:
        print(f"ERROR: {ve}")
        return # Exit on value error
    except Exception as e:
        print(f"An unexpected error occurred while reading the CSV: {e}")
        return # Exit on other read errors

    # Process and write row by row
    print(f"Processing positions and saving to '{output_csv_path}'...")
    with open(output_csv_path, 'w', newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerow(all_columns) # Write header row

        # Wrap the iteration with tqdm for a progress bar
        # Use `ascii=True` if running in environments that don't support Unicode characters
        for i, (fen, eval_score) in tqdm(enumerate(positions_to_process), total=total_positions, desc="Processing Positions", ascii=True):

            # Handle visualization for the first N positions
            if i < visualize_first_n:
                 try:
                     # Re-parse FEN and calculate attack map just for visualization
                     fen_data_viz = parse_fen(fen)
                     board_arr_viz = fen_data_viz["board_array"]
                     attack_m_viz = calculate_attack_map(board_arr_viz)
                     print(f"\n--- Visualizing Position {i+1} ---")
                     visualize_position(fen, board_arr_viz, attack_m_viz)
                 except Exception as e:
                     print(f"Error visualizing FEN: {fen}. Error: {e}")


            try:
                # Process the position to get features
                processed_features = process_chess_position(fen, eval_score)

                # --- Debugging: Uncomment the line below if you suspect feature count issues ---
                # print(f"Processing FEN: {fen}. Length of processed_features: {len(processed_features)}")
                # --- End Debugging ---

                # Validate feature count before writing
                if len(processed_features) != expected_feature_count:
                     print(f"Skipping FEN due to incorrect feature count: {fen}. Expected {expected_feature_count}, got {len(processed_features)}")
                     continue # Skip writing this row if feature count is wrong

                # Write the processed features as a row to the output CSV
                writer.writerow(processed_features)

            except Exception as e:
                print(f"Error processing FEN: {fen}. Error: {e}. Skipping this row.")
                # Continue to the next row

    print(f"\nProcessing complete.")

    # Optional: Load and display head of the saved DataFrame for verification
    try:
        # Use pandas to read the first few rows of the *output* file
        output_df_head = pd.read_csv(output_csv_path, nrows=5)
        print(f"\nGenerated DataFrame head (from saved CSV: '{output_csv_path}'):")
        print(output_df_head)
    except FileNotFoundError:
        print(f"Could not read saved CSV at '{output_csv_path}' for verification.")
    except Exception as e:
        print(f"Error reading saved CSV head: {e}")


# --- Main Execution ---
if __name__ == '__main__':
    # Configuration for CSV file paths
    # Using relative paths makes it easier to run in different environments like Colab
    # If using Google Drive in Colab, you might need paths like '/content/drive/MyDrive/...'
    INPUT_CSV_PATH = '/content/drive/MyDrive/Msc Jave/Sistemas inteligentes - Sem 1/chessData.csv'
    OUTPUT_CSV_PATH = '/content/drive/MyDrive/Msc Jave/Sistemas inteligentes - Sem 1/Proyecto RcI/processed_chess_data2.csv'
    VISUALIZE_FIRST_N_POSITIONS = 1 # Set to > 0 to visualize the first N processed positions

    # Create a dummy input CSV for testing if it doesn't exist
    # This helps ensure the script can run even without your specific input file
    try:
        # Check if the input file exists by trying to read it
        pd.read_csv(INPUT_CSV_PATH)
        print(f"Input file '{INPUT_CSV_PATH}' found.")
    except FileNotFoundError:
        print(f"Input file '{INPUT_CSV_PATH}' not found. Creating a dummy file for demonstration.")
        dummy_data = {
            'FEN': [
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", # Starting position
                "r1bqkbnr/pp1ppppp/n7/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 2", # Example middle game
                "rnbq1bnr/pp1pkNpp/8/2p1Q3/4P3/8/PPPP1PPP/RNB1KB1R b KQ - 0 5", # Example with check/capture
                "8/8/8/8/8/8/8/8 w - - 0 1", # Empty board
                "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1", # Pawn move, en passant possibility
                "invalid fen string", # To test error handling
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" # Another valid one
            ],
            'Evaluation': [0.0, 0.1, 9.5, 0.0, 0.2, 0.0, 0.0] # Example evaluation scores
        }
        pd.DataFrame(dummy_data).to_csv(INPUT_CSV_PATH, index=False)
        print(f"Dummy '{INPUT_CSV_PATH}' created. Please replace it with your actual data file.")

    # Process and save the data using the memory-efficient function
    process_and_save_chess_data(INPUT_CSV_PATH, OUTPUT_CSV_PATH, visualize_first_n=VISUALIZE_FIRST_N_POSITIONS)